1. Modern OO is copying FP because it’s better, but OO compilers can’t handle its requirements
2. Why does FP matter? (Immutability, generative testing, pure functions, laziness, etc.)
3. Intro: Type Theory and its motivations for programming. Monoids, Functors, Monads, Semigroups? Demystify from beginning that these are mathematical terms for combination, generic application, generic context, and complex sets, and that we just meed to remember the names to pay respect to the mathematicians that came up with the concepts)
4. Compilation as the first step in your test plan (explain how a modern FP test plan looks like compared to the traditional TDD approach used in procedural and OO
5. Domain modelling , type classes and type families
6. Pattern matching, guards, if-else
7. List comprehensions, spines, and folds
8. Apis in Haskell (Servant)
9. Databases in Haskell (Persistent, FRM vs ORM)
10. Integrations & nixpkgs
11. Cross platform development with Obelisk & Reflex-FRP



Notes for tutorial style:
- show verbosity first and then show syntax sugar
- Use a domain that explains all concepts well and explains why things are done
